#! /usr/bin/perl

use Getopt::Long;
use Cwd;
use File::Path;
use File::Spec;

## Options, w/ default values
$database	= "BackupDB";
$verbose	= 0;
$help		= 0;
$tmpbase	= "/tmp/backup/disc";
$isobase	= "disc";
$mkiso		= 0;
$keep		= 0;
$catalog	= 0;
$symlink	= 1;
$maxDisc	= 0;
$purge		= 0;
$root		= undef;

$linktype	= "hard";

$result = GetOptions(
                     "database|db=s" 	=> \$database,
		     "tmp=s"		=> \$tmpbase,
		     "keeptemp!"	=> \$keep,
		     "mkiso!"		=> \$mkiso,
		     "iso=s"		=> \$isobase,
		     "catalog!"		=> \$catalog,
		     "symlink!"		=> \$symlink,
		     "purge!"		=> \$purge,
                     "verbose+" 	=> \$verbose,
		     "root=s"		=> \$root,
                     "help"		=> \$help
                     );

if ($help || !$result) {
    usage();
    exit;
}

$linktype = "soft" if ($symlink);

loadDB($database);

if (@ARGV) {
    @discs = setDiscs(@ARGV);
} else {
    @discs = sort { $a <=> $b} keys %DISCS;
}


if ($root) {
    $root = File::Spec->canonpath($root);
}

## Check to see if any of the discs we want already exist
$dirsExist = 0;
foreach $disc (@discs) {
    $dir = File::Spec->canonpath("$tmpbase.$disc");
    if (-e $dir) {
	if ($purge) {
	    print "Directory $dir exists.  Purging\n" if ($verbose);
	    rmtree($dir) || die "Could not remove $dir\n";
	} else {
	    print "Directory $dir exists.\n";
	    $dirsExist = 1;
	}
    }
}

die "Some directories already exist.  Use -p to purge\n" if ($dirsExist);


foreach $disc (@discs) {
    $dir = File::Spec->canonpath("$tmpbase.$disc");
    mkTmpDir($disc, $dir);
    $output = File::Spec->canonpath("$isobase.$disc.iso");
    runMkISO($disc, $dir, $output) if ($mkiso);
    cleanup($dir) unless ($keep || !$mkiso);
}

sub setDiscs {
    my @args = @_;
    my @retList = ();
    foreach my $arg (@args) {
	if ($arg =~ /([0-9]+)\-([0-9]+)/) {
	    push @retList, ($1 .. $2);
	} elsif ($arg =~ /([0-9]+)\-/) {
	    push @retList, ($1 .. $maxDisc);
	} else {
	    push @retList, $arg;
	}
    }
    return sort { $a <=> $b} @retList;
}

sub mkTmpDir {
    my $disc = shift;
    my $dir = shift;
    my $files = 0;

    print "Building disc $disc in $dir\n" if ($verbose);

    foreach my $file (sort {$a cmp $b} keys %DB) {
	next unless ($DB{$file}->{"disc"} == $disc);
	$files++;
	my $shortname = $file;
	$shortname =~ s/^$root//g;
	my $fileloc = File::Spec->canonpath(File::Spec->catdir($dir, $shortname));
	my ($volume, $filedir, $dummy) = File::Spec->splitpath($fileloc);
	mkpath($filedir) unless (-d $filedir);
	print "$disc:$file : $fileloc : $filedir\n" if ($verbose > 1);
	doLink(Cwd::realpath($file), $fileloc) || die "Could not make $linktype link to $fileloc\n";;
    }
    return if ($files == 0);
    my ($dummy, $dummy, $dbFileName) =  File::Spec->splitpath($database);
    my $dbDest = File::Spec->catfile($dir, $dbFileName);
    print "$disc: Adding catalog $dbFileName ($dbDest)\n" if ($verbose > 1);
    doLink(Cwd::realpath($database), Cwd::realpath($dbDest)) if ($catalog);
}

sub doLink {
    my ($src, $dest) = @_;
    if ($symlink){
	symlink $src, $dest;
    } else {
	link $src, $dest;
    }
}

sub runMkISO {
    my $disc = shift;
    my $dir = shift;
    my $output = shift;

    print "Making ISO Image of $disc in $output from $dir\n";
    system ("mkisofs -r -R -l -f -q -input-charset=iso8859-1 -o $output $dir");
}

sub cleanup {
    my $dir = shift;
    print "Cleaning up $dir\n" if ($verbose);
    rmtree ($dir);
}

sub loadDB {
    my $db = shift;
    open DBFILE, "< $db" || die "Could not open $db\n";
    while (<DBFILE>) {
	chomp;
	my ($size, $mtime, $disc, $file) = split (/\|/);
	$dir = $file;
	$dir =~ s/\/[^\/]+$//g;
	print "Loading $file\n" if ($verbose > 2);
	addFile($file, $size, $mtime, $dir, $disc);
	$DISCS{int $disc} = 1;
    }
    close DBFILE;
}

sub addFile {
    my ($file, $size, $mtime, $dir, $disc) = @_;
    $DB{$file} = {
	"file"  => $file,
	"size"  => $size,
	"mtime" => $mtime,
	"dir"   => $dir,
	"disc"  => int $disc
	};
    $maxDisc = $disc if ($disc > $maxDisc);
}

sub usage {
    print <DATA>;
}
__DATA__
	-v	--verbose	print more information
	-d	--database	database to use.  Default is BackupDB.
	-k	--keeptemp	Keep temporary directories around.
	-f	--fill		Continue to fill last disc.
	-t 	--tempdir	Specify the name of the disc files.
	-m	--mkiso		Actually build the ISO images.
	-i	--isobase	Basename of ISO images.
	-c	--catalog	Include the catalog/BackupDB in all discs.
	-s	--symlink	Use symbolic links instead of hard links.
	-p	--purge		Purge out old files.
	-r	--root		Remove this root directory string.
	-h	--help		This screen.
	
