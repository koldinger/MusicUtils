#! /usr/bin/perl
# Copyright Eric Koldinger, 2006
# kolding @ koldware.com
# No warranty, expressed, or implied, if you use this program.  Author is not responsible for any
# damage it may do to your files or sanity.

use MP3::Tag;
use Audio::FLAC::Header;
#use Audio::M4P::QuickTime;
use MP4::Info;
use Getopt::Long;
use Unicode::String;
use Unicode::Normalize;
use File::Spec;
use File::Path;
use File::Copy;
use String::Util qw(trim);
use Cwd;
use Memoize;

foreach $i (qw(collectTagsMP3 collectTagsMP4 collectTagsFlac)) {
    memoize($i)
}

# Set up options processing
$mp3base        = "/srv/music/MP3/CD";
$flacbase       = "/srv/music/FLAC";
$mp4base        = "/srv/music/MP4";
$base           = $m43base;
$variousArtists = "VariousArtists";
$classicalName  = "Classical";
$noArtist       = "NoArtist";
$utf8           = 1;
$compilation    = 0;
$classical      = 0;
$dorename       = 1;
$cleanUp        = 0;
$split          = 0;
$inplace        = 0;
$dots           = 0;
$albumArtist    = 0;
$quiet          = 0;
$removeDups     = 0;
$link           = 0;
$useArticle     = 1;
$maxNameLen     = 75;
$normalize      = 0;
$accents        = 0;
$cddbName       = 0;
@dragfiles      = ();

$result = GetOptions(
             "utf8!"        =>  \$utf8,
             "base=s"       =>  \$base,
             "compilation"  =>  \$compilation,
             "classical"    =>  \$classical,
             "various=s"    =>  \$variousArtists,
             "drag=s"       =>  \@dragfiles,
             "rename!"      =>  \$dorename,
             "clean!"       =>  \$cleanUp,
             "split!"       =>  \$split,
             "inplace!"     =>  \$inplace,
             "RemoveDups!"  =>  \$removeDups,
             "flacbase=s"   =>  \$flacbase,
             "mp3base=s"    =>  \$mp3base,
             "mp4base=s"    =>  \$mp4base,
             "dots!"        =>  \$dots,
             'albartist!'   =>  \$albumArtist,
             "length=i"     =>  \$maxNameLen,
             "link!"        =>  \$link,
             #"normalize!"   =>  \$normalize,
             #"accents!"     =>  \$accents,
			 "cddb!"		=>  \$cddbName,
             "the!"         =>  \$useArticle,
             "quiet!"       =>  \$quiet,
             "help"         =>  \$help
             );

if (!$result)
{
    print "Invalid options\n";
}

$flacbase = $base unless ($split);
$mp3base = $base unless ($split);
$mp4base = $base unless ($split);

if ($help || !$result) {
    usage();
    exit;
}

if (@dragfiles == 0) { @dragfiles = ("cover.jpg", "disc.json"); }

@dragfiles = split(/,/,join(',',@dragfiles));

## Now, parse the various files
foreach $file (@ARGV)
{
    if (-d $file) { 
        reorgDir($file);
    } else {
        renameFile($file);
    }
}

$numFailures;

sub reorgDir {
    my $dir = shift;
    opendir DIRHANDLE, "$dir" || die "Could not open directory $dir\n";
    my @names = readdir(DIRHANDLE);
    closedir DIRHANDLE;

    my ($artist, $album, $title, $genre, $track, $disc, $composer, $vaTag);
    my @composers;

    my @files = map { File::Spec->catfile($dir, $_); } File::Spec->no_upwards(@names);

    foreach my $path (sort @files) {
        next unless (-e $path);
        next if (-d $path);
        print $path, "\n";
        if ($path =~ /\.mp3$/) {
            ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsMP3($path);
            $suffix = ".mp3"; $basedir = $mp3base;
        } elsif ($path =~ /\.flac$/) {
            ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsFlac($path);
            $suffix = ".flac"; $basedir = $flacbase;
        } elsif ($path =~ /\.m4a$/) {
            ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsMP4($path);
            $suffix = ".m4a"; $basedir = $mp4base;
        }
        push @composers, $composer if (defined $composer && !contains($composer, @composers));
    }

    @composers = sort { $a cmp $b } @composers;
    if (@composers > 2) {
        $composers = join (" & ", $composers[0], "et al");
    } else {
        $composers = join (" & ", @composers);
    }

    foreach my $path (sort @files) {
        next unless (-e $path);
        if (-d $path) {
            reorgDir($path);
        } else {
            renameFile($path, $composers);
        }
    }
}


sub renameFile {
    my $file = shift;
    my $composerString = shift;
    my $result;
    my $artist, $album, $title, $album, $track, $disc, $genre, $composer, $vaTag;
    my $suffix, $basedir;
    if ($file =~ /\.mp3$/) {
        ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsMP3($file);
        $suffix = ".mp3"; $basedir = $mp3base;
    } elsif ($file =~ /\.flac$/) {
        ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsFlac($file);
        $suffix = ".flac"; $basedir = $flacbase;
    } elsif ($file =~ /\.m4a$/) {
        ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb) = collectTagsMP4($file);
        $suffix = ".m4a"; $basedir = $mp4base;
    } else {
        #msg("$file: Not tagged type\n");
        return;
    }
    if (!defined $album) {
        $result = $artist;
        chomp $result;
        msg($result, "\n");
        $numFailures++;
        return;
    }
    my $clTag = 1 if ($genre =~ /^[Cc]lassical/);
    my $dir = makeDirName($artist, $vaTag, $clTag, $composerString);
    doRename($file, $dir, $album, $title, $track, $disc, $basedir, $suffix, $cddb);
}

sub collectTagsFlac {
    my $file = shift;
    my $vaTag = 0;
    my $disc = undef;
    my $composer = undef;
    my $flac = Audio::FLAC::Header->new($file)  || return "Could not read tags from $file";
    my $tags = $flac->tags() || return "No tags found in $file";
    my $artist = latin1($tags->{"ARTIST"}) || latin1($tags->{"artist"});
    my $album  = latin1($tags->{"ALBUM"})  || latin1($tags->{"album"})     || return "No album tag in $file";
    my $title  = latin1($tags->{"TITLE"})  || latin1($tags->{"title"})     || return "No title tag in $file";
    $title = $title . ", " . latin1($tags->{"PART"}) if (defined $tags->{"PART"});
    my $genre  = latin1($tags->{"GENRE"})  || latin1($tags->{"genre"});
    my $track  = int($tags->{"TRACKNUMBER"}) || latin1($tags->{"tracknumber"})  || return "No track tag in $file";;
	my $cddb   = latin1($tags->{"CDDB"});
    $composer = latin1($tags->{"COMPOSER"});

    if ($albumArtist) {
        $albArtist = $tags->{"ALBUMARTIST"};
        $artist = latin1($albArtist) if defined($albArtist);
    }

    $disc  = int ($tags->{"SET"}) if (defined $tags->{"SET"});
    $disc  = int ($tags->{"DISCNUMBER"}) if (defined $tags->{"DISCNUMBER"});

    my $vaTag = 1 if (defined $tags->{"COMPILATION"});
    return ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb);
}

sub collectTagsMP4 {
    my $file = shift;
    my $vaTag = 0;
    my $disc = undef;
    my $composer = undef;
    my $mp4 = MP4::Info->new($file)  || return "Could not read tags from $file";
    my $artist = latin1($mp4->{ART});
    my $album  = latin1($mp4->{ALB}) || return "No album tag in $file";
    my $title  = latin1($mp4->{NAM}) || return "No title tag in $file";
    $title = $title . ", " . latin1($mp4->{GRP}) if (defined $mp4->{GRP});
    my $genre  = latin1($tags->{GENRE});
    my $track  = ($mp4->{TRACKNUM}) || return "No track tag in $file";;
	my $cddb   = undef;
    $composer = latin1($mp4->{WRT});

    if ($albumArtist) {
        $albArtist = $mp4->{"AART"};
        $artist = latin1($albArtist) if defined($albArtist);
    }

    $disc  = int ($mp4->{"SET"}) if (defined $mp4->{"SET"});
    $disc  = int ($mp4->{"DISCNUMBER"}) if (defined $mp4->{"DISCNUMBER"});

    my $vaTag = 1 if (defined $tags->{"COMPILATION"});
    return ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb);
}

sub collectTagsMP3 {
    my $file = shift;
    my $vaTag = 0;
	my $cddb = undef;
    my $disc = undef;
    my $composer = undef;
    my $mp3 = MP3::Tag->new($file)      || return "Could not read $file";
    $mp3->get_tags()                    || return "Could not get tags in $file";
    my $artist = utf8($mp3->artist());
    my $album  = utf8($mp3->album())    || return "No album tag in $file";
    my $title  = utf8($mp3->title())    || return "No title tag in $file";
    my $genre  = utf8($mp3->genre());
    my $track  = $mp3->track()          || return "No track tag in $file";

    my $id3v2 = $mp3->{ID3v2};
    my ($info, $name, @rest) = $id3v2->get_frame("TPOS") if (defined $id3v2);
    $disc  = int ($info) if (defined $info);
    ($info, $name, @rest) = $id3v2->get_frame("TCOM") if (defined $id3v2);

    $composer = utf8($info) if (defined $info);

    ($info, $name, @rest) = $id3v2->get_frame("TCMP") if (defined $id3v2);
    $vaTag = 1 if (defined $info);

    if ($albumArtist) {
        ($info, $name, @rest) = $id3v2->get_frame("TPE2") if (defined $id3v2);
        $artist = utf8($info) if (defined $info);
    }

    if (defined $id3v2) {
        my ($txxx, $name) = $id3v2->get_frame("TXXX");
        if ((defined $txxx) && ($txxx->{"Description"} eq "CDDB"))
        {
            ($cddb) = split/,/, $txxx->{"Text"};
        }
    }

    return ($artist, $album, $title, $genre, $composer, $track, $disc, $vaTag, $cddb);
}

sub makeDirName {
    my ($artist, $vaTag, $clTag, $clDir) = @_;
    $dir = munge($artist);
    $dir = munge($variousArtists)   if ($vaTag || $compilation);
    if ($clTag || $classical) {
        $dir = munge($classicalName);
        $dir = File::Spec->catdir($dir, munge($clDir)) if (defined $clDir) 
    }
    $dir = munge($noArtist)     unless defined $dir;
    return $dir;
}

sub doRename {
    my ($file, $dir, $album, $title, $trackNum, $disc, $basedir, $suffix, $cddb) = @_;

    $track = int($trackNum);
    $track = "0$track" if ($track < 10);
    $track = "$disc-$track" if (defined $disc && !$cddbName);

    my $newdir;
    if ($inplace) {
        my $sink;
        ($sink, $newdir, $sink) = File::Spec->splitpath(Cwd::realpath($file));
    } else {
        $newdir = File::Spec->catdir($basedir, $dir, munge($album));
    }

	my $newfile;
	if ($cddbName) {
		$newfile = "$cddb-$track" . $suffix;
	} else {
		$newfile = "$track." . munge($title) . $suffix;
	}
    my $newpath = File::Spec->catfile($newdir, $newfile);
    if (Cwd::realpath($file) eq Cwd::realpath($newpath)) {
        #msg("Not moving $file.  Name not changed\n");
        return 0;
    }
    $action = "Moving ";
    $action = "Linking " if $link;
    msg("$action$file => $newpath\n");
    if ($dorename) {
        mkpath($newdir) || return "Could not create directory $newdir" unless (-d $newdir);
    }
    if (-e $newpath) {
        if ($removeDups) {
            if ($dorename) {
                unlink ($file) || return "Could not delete duplicate file $file\n";
            }
            return "Removed duplicate file $file\n";
        }
        return "$file Target $newpath exists.  Not moved."
    } else {
        if ($link) {
            link($file, $newpath) if ($dorename) || return "Could not link $file to $newpath\n";
        } else {
            rename($file, $newpath) if ($dorename) || return "Could not move $file to $newpath\n";
        }
    }
    drag($file, $newdir);
    purgeDir($file) if ($cleanUp);
    0;
}

sub purgeDir {
    my $file = shift;
    my ($sink, $dir, $sink) = File::Spec->splitpath($file);
    opendir (DIR, $dir) || return;
    my $numFiles = File::Spec->no_upwards(readdir(DIR));
    closedir DIR;
    if ($numFiles == 0) {
        msg("Removing empty directory $dir\n");
        rmtree($dir);
    }
}

$lastOldDir = undef;
$lastNewDir = undef;

sub drag {
    my ($file, $newdir) = @_;
    my ($sink, $olddir, $sink) = File::Spec->splitpath($file);
    if (($olddir ne $lastOldDir) || ($newdir ne $lastNewDir)) {
        doDrag($olddir, $newdir);
        $lastOldDir = $olddir;
        $lastNewDir = $newdir;
    }
}

sub doDrag {
    my ($olddir, $newdir) = @_;
    foreach my $file (sort @dragfiles) {
        my $oldpath = File::Spec->catfile($olddir, $file);
        if (-e $oldpath) {
            my $newpath = File::Spec->catfile($newdir, $file);
            if (Cwd::realpath($oldpath) eq Cwd::realpath($newpath)) {
                msg("Not moving $oldpath.  Name not changed\n");
                next;
            }
            msg("Dragging $oldpath to $newpath\n");
            if ($dorename) {
                mkpath($newdir) || return "Could not create directory $newdir" unless (-d $newdir);
            }
            if (-e $newpath) {
                return "$file Target $newpath exists.  Not moved."
            } elsif ($split) {
                copy($oldpath, $newpath) if ($dorename) || die "Could not copy $oldpath to $newpath\n";
            } else {
                if ($link) {
                    link $oldpath, $newpath if ($dorename) || die "Could not link $oldpath to $newpath\n";
                } else {
                    rename $oldpath, $newpath if ($dorename) || die "Could not move $oldpath to $newpath\n";
                }
            }
        }
    }
}

sub munge {
    #echo "$@" | sed s,:,\ -,g | tr \ / __ | tr -d \'\"\?\[:cntrl:\]
    my $name = shift;
    my $oldname = $name;

    $name = $2 if (!$useArticle && $name =~ /^(The|A|An)\s+(.*)$/);

    $name =~ s/[&,\[\]\$\"\'\?\(\)\<\>\!]//g;
    $name =~ s/:/_-/g;
    $name =~ s/[\.]//g if ($dots == 0);
    $name = trim($name);
    $name =~ s/[ \/]/_/g;
    $name =~ s/__/_/g;
    $name =~ s/_$//g;
    if ($maxNameLen != -1 && length($name) > $maxNameLen) {
        $name = substr($name, 0, $maxNameLen);
    }
    return $name;
}

sub utf8 {
    my $name = shift;
    return undef if (!defined $name);
    $name = Unicode::String::latin1($name)->utf8() if ($utf8);
    return $name;
}
sub latin1 {
    my $name = shift;
    return undef if (!defined $name);
    $name = Unicode::String::utf8($name)->latin1() if (!$utf8);
    return $name;
}

sub contains {
    my $element = shift;
    my @list = @_;
    foreach my $listElem (@list) {
        return 1 if ($listElem eq $element);
    }
    return 0;
}

sub msg {
    my $message = shift;
    print $message unless $quiet;
}

sub usage {
    print <DATA>;
}

__DATA__
    -u  --utf8      Create target filenames in UTF8
    -b path --base=path Create Targets in path.  Must be in the same filesystem as originals.
    -v name --various=name  Name of Various Artists directory.
    -d  --drag=s    Drag files with this name along with music files.  Multiple can be specified.
        --clean     Cleanup empty directories and dragged files when done.
    -s  --[no]split Split the files between FLAC and MP3 files.
    -f  --flacbase  Base directory for FLAC files
    -m  --mp3base   Base directory for MP3 files
        --compliation   Assume this is a compilation (Various Artists) disc.
        --classical Assume this is a classical disc.  Use Classical naming.
    -i  --[no]inplace   Change the file names in the current directory only.  Do not move to other dirs
    -r  --[no]rename    Actually do the rename (--norename for dry run)
    -l len  --length=n  Set the maximum length of any name component to len
    -R  --[no]RemoveDups    Remove files if the target already exists.
	    --[no]cddb			Name files cddbId-track.
    -L --[no]link           Link files instead of moving.
    -q  --[no]quiet Be quiet.  No output
    -h  --help      This screen.
