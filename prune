#! /usr/bin/perl

use File::Spec;
use File::Path;
use Term::ANSIColor;
use Getopt::Long;

@deleteable      = ();
$dryRun          = 0;

$result = GetOptions(
                     "delete=s"   =>      \@deleteable,
                     "N|dryrun!"   =>     \$dryRun,
                     );

push @ARGV, "." if (@ARGV == 0);

print $dryRun;

makeHash(@deleteable);

foreach $i (@ARGV) {
    $dirSize = prune($i) if (-d $i);
    if ($dirSize == 0 && $i ne ".") { rmtree($i); }
}

sub prune {
    my $dir = shift;
    return 1 unless (-d $dir);
    opendir DIR, $dir || return 1;
    my @files = File::Spec->no_upwards(readdir DIR);
    closedir DIR;

    my $numFiles = @files;
    print "Pruning $dir\n";

    if ($numFiles == 0) { return 0; }
    foreach my $file (@files) {
        my $path = File::Spec->join($dir, $file);
        if (-d $path) {
            if (prune ($path) == 0) {
			print color 'bold blue';
            print "Deleting empty directory: $path\n";
			print color 'reset';
            rmtree($path) unless $dryRun;
            $numFiles --;
            }
        }
    }
    # Count the number of files left which can be deleted.
    my $numDelete = countDeletable(@files);
    # Match it with what's there.
    return ($numFiles - $numDelete);
}

sub countDeletable {
    my $count = 0;
    foreach my $file (@_) {
        $count ++ if (exists $delete{$file});
    }
    return $count;
}

sub makeHash {
    foreach my $file (@_) {
        $delete{$file} = 1;
    }
}
